#include "funcPart_00_09.h"

/*
* 	int परीक्षणপরীক্ষাבדיקהاختبارტესტიපරීක්ෂණයपरीक्षा😊 = -1;

😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊
😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊
😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊
😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊
😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊
😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊
😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊
😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊
😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊
😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊
😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊
😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊
😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊
😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊
😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊
😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊
😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊
😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊
😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊
😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊
😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊
😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊
😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊
😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊
😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊
😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊
😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊
😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊
😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊
😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊
😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊
😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊
😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊
😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊
😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊
😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊
😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊
😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊
😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊😊


*/








//boost精度浮點數library
#include "boost/multiprecision/cpp_dec_float.hpp"
#include <random>
#include <iostream>
#include <iomanip>
#include <ctime>


//變數型態替換
#define cull constexpr unsigned long long 
#define ull unsigned long long 
#define ld  long double

//環境常數
cull PRECISION = 10;//浮點數精度
//boost::multiprecision
using namespace boost::multiprecision;
typedef number<cpp_dec_float<PRECISION>> PRECISION_float;

/*Probability Final Project -1*/
//選擇性: 打印資料,當需要效率時請關閉
#define Probability_Final_Project_1_PRINT_MODE false
//選擇性: 完整模擬而非出現兩人同日生日就進行下一次模擬
#define Probability_Final_Project_1_FULL_SIMULATION_MODE false
//選擇性: 無限進行實驗
#define Probability_Final_Project_1_INFINITE_LOOP_MODE true
//選擇性: 停用
#define Probability_Final_Project_1_STOP_MODE true


/*Probability Final Project -1*/
void funcPart00()
{
#if !Probability_Final_Project_1_STOP_MODE

	//變量常數
	cull DAYS_OF_YEAR = 365;//一年幾天
	cull NUMBER_OF_PEOPLE = 23;//人數

	//使用時間作為亂數種子
	std::mt19937 generator(time(nullptr));
	std::uniform_int_distribution<int> distribution(0, DAYS_OF_YEAR - 1);



	//Probability_Final_Project_1_PRINT_MODE常數
#if Probability_Final_Project_1_PRINT_MODE
	cull NUMBER_OF_LINE = 73;//行數
#endif//Probability_Final_Project_1_PRINT_MODE

	//Probability_Final_Project_1_INFINITE_LOOP_MODE常數
#if Probability_Final_Project_1_INFINITE_LOOP_MODE
	cull AFTER_X_EXPERIMENT_PRINT = 10000000;//模擬x次後輸出1次
#endif//Probability_Final_Project_1_INFINITE_LOOP_MODE

	//Probability_Final_Project_1_INFINITE_LOOP_MODE常數，無限模式請勿改動
#if Probability_Final_Project_1_INFINITE_LOOP_MODE==false
	PRECISION_float NUMBER_OF_EXPERIMENT_REPEATED = 1000000;//做幾次實驗
#else//Probability_Final_Project_1_INFINITE_LOOP_MODE
	PRECISION_float cpp_dec_float_numberOfExperimentRepeated = 0;
	ull ull_numberOfExperimentRepeated = 0;
#endif//Probability_Final_Project_1_INFINITE_LOOP_MODE

	//變量
	PRECISION_float fail = 0;


	/*附加變量:Probability_Final_Project_1_FULL_SIMULATION_MODE*/
	bool failed = false;

	/*常數範圍判斷*/
	if (NUMBER_OF_PEOPLE > DAYS_OF_YEAR)
	{
		std::cout << "人比天數還多,必存在兩人同日生日,Probability = 0\n";
		return;
	}

	// 永遠執行
#if Probability_Final_Project_1_INFINITE_LOOP_MODE
	while (true)
		//有限執行
#else//Probability_Final_Project_1_INFINITE_LOOP_MODE
	for (int j = 0; j < NUMBER_OF_EXPERIMENT_REPEATED; j++)

#endif//Probability_Final_Project_1_INFINITE_LOOP_MODE
	{
		unsigned short boolArray[DAYS_OF_YEAR] = { 0 };
		unsigned short temp[NUMBER_OF_PEOPLE] = { 0 };

		//標題輸出
#if Probability_Final_Project_1_PRINT_MODE
#if Probability_Final_Project_1_INFINITE_LOOP_MODE == false

		std::cout << "==== the " << j + 1 << "th experiment report====\n";
#elif Probability_Final_Project_1_INFINITE_LOOP_MODE
		std::cout << "==== the " << ull_numberOfExperimentRepeated << "th experiment report====\n";
#endif //Probability_Final_Project_1_INFINITE_LOOP_MODE

#endif//Probability_Final_Project_1_PRINT_MODE

		// flag重置
#if Probability_Final_Project_1_FULL_SIMULATION_MODE
		failed = false;
#endif//Probability_Final_Project_1_FULL_SIMULATION_MODE

		/*核心模擬*/
		for (int i = 0; i < NUMBER_OF_PEOPLE; i++)
		{
			temp[i] = distribution(generator);
			boolArray[temp[i]] += 1;

			//失敗
			if (boolArray[temp[i]] >= 2)
			{
#if Probability_Final_Project_1_FULL_SIMULATION_MODE
				//避免重複添加失敗次數
				if (failed == false)fail += 1;
				failed = true;
#elif Probability_Final_Project_1_FULL_SIMULATION_MODE==false
				fail += 1;
				////失敗後重置更動位 //使用局部變量省下此步驟
				//for (int k = 0; k <= i; k++)
				//{
				//	boolArray[temp[k]] = 0;
				//}				
				break;
#endif // !Probability_Final_Project_1_FULL_SIMULATION_MODE
			}

		}

		////成功後更動位清零 //使用局部變量省下此步驟
		//for (int i = 0; i < NUMBER_OF_PEOPLE; i++)
		//{
		//	boolArray[temp[i]] = 0;
		//}

		//輸出函數
#if Probability_Final_Project_1_PRINT_MODE
		/*附加: 打印boolArray*/
		for (int i = 0; i < DAYS_OF_YEAR; i++)
		{
			//輸出
			if (boolArray[i] >= 2)
			{
				printf("\033[31m%lld\033[0m ", boolArray[i]);

			}
			else if (boolArray[i] == 0 || boolArray[i] == 1)
			{
				std::cout << boolArray[i] << " ";
			}
			//換行
			if ((i + 1) % NUMBER_OF_LINE == 0 && i != 0)std::cout << '\n';

		}
		std::cout << '\n';
#endif//Probability_Final_Project_1_PRINT_MODE

		//Probability_Final_Project_1_INFINITE_LOOP_MODE輸出
#if Probability_Final_Project_1_INFINITE_LOOP_MODE
		cpp_dec_float_numberOfExperimentRepeated += 1;
		ull_numberOfExperimentRepeated += 1;

		if (ull_numberOfExperimentRepeated % AFTER_X_EXPERIMENT_PRINT == 0)
		{
			std::cout << "Number of experiment repeated: " << cpp_dec_float_numberOfExperimentRepeated << '\n';
			std::cout << "Success:" << cpp_dec_float_numberOfExperimentRepeated - fail << '\n';
			std::cout << "Fail:" << fail << '\n';

			std::cout << "Probability: " << std::setprecision(PRECISION) << (cpp_dec_float_numberOfExperimentRepeated - fail) / (cpp_dec_float_numberOfExperimentRepeated) << "\n\n";
		}

#endif//Probability_Final_Project_1_INFINITE_LOOP_MODE

	}
	//正常輸出
#if Probability_Final_Project_1_INFINITE_LOOP_MODE == false
	std::cout << "Number of experiment repeated: " << NUMBER_OF_EXPERIMENT_REPEATED << '\n';
	std::cout << "Success:" << NUMBER_OF_EXPERIMENT_REPEATED - fail << '\n';
	std::cout << "Fail:" << fail << '\n';

	std::cout << "Probability: " << std::setprecision(PRECISION) << (NUMBER_OF_EXPERIMENT_REPEATED - fail) / (NUMBER_OF_EXPERIMENT_REPEATED) << '\n';
#endif //Probability_Final_Project_1_INFINITE_LOOP_MODE == false
#endif // !Probability_Final_Project_1_STOP_MODE
}

/*Probability Final Project -2*/
//選擇性: 打印資料,當需要效率時請關閉
#define Probability_Final_Project_2_PRINT_MODE false
//選擇性: 無限進行實驗
#define Probability_Final_Project_2_INFINITE_LOOP_MODE true
//選擇性: 停用全部
#define Probability_Final_Project_2_STOP_MODE false
//選擇性: 停用STRAIGHT
#define Probability_Final_Project_2_STRAIGHT_STOP_MODE false
//選擇性: 停用FULL_HOUSE
#define Probability_Final_Project_2_FULL_HOUSE_STOP_MODE false
//選擇性: 停用FLUSH
#define Probability_Final_Project_2_FLUSH_STOP_MODE false


#include <vector>
#include <utility>

/*Probability Final Project -2*/
void funcPart01()
{
#if !Probability_Final_Project_2_STOP_MODE 

	//數據常數
	cull NUMBER_OF_FLOWERS = 4;//花色數量
	cull NUMBER_OF_CARDS_PER_FLOWERS = 13;//每個花色的牌數
	cull NUMBER_TO_DEALT = 5;//要抽的牌數

	//使用時間作為亂數種子
	std::mt19937 generator(time(nullptr));
	std::uniform_int_distribution<int> Flowers_Random(0, NUMBER_OF_FLOWERS* NUMBER_OF_CARDS_PER_FLOWERS - 1);


	/*常數範圍判斷*/
	if (NUMBER_TO_DEALT > NUMBER_OF_CARDS_PER_FLOWERS * NUMBER_OF_FLOWERS)
	{
		std::cout << "要抽得牌比排還多,Probability = 0\n";
		return;
	}

	//變量
	PRECISION_float straightSuccess = 0;//straight的成功次數
	PRECISION_float fullHouseSuccess = 0;//fullHouse的成功次數
	PRECISION_float flushSuccess = 0;//flush的成功次數

#if !Probability_Final_Project_2_INFINITE_LOOP_MODE
	//常數
	PRECISION_float NUMBER_OF_EXPERIMENT_REPEATED = 10000;//做幾次實驗
#else//Probability_Final_Project_2_INFINITE_LOOP_MODE
	//常數
	cull AFTER_X_EXPERIMENT_PRINT = 5000000;//模擬x次後輸出1次

	//變量
	PRECISION_float cpp_dec_float_numberOfExperimentRepeated = 0;
	ull ull_numberOfExperimentRepeated = 0;
#endif//Probability_Final_Project_2_INFINITE_LOOP_MODE


#if Probability_Final_Project_2_INFINITE_LOOP_MODE
	while (true)
	{
#else
	for (int j = 0; j < NUMBER_OF_EXPERIMENT_REPEATED; j++)
	{
#endif
		std::vector<std::pair<int, int>> points;//儲存抽到的牌的(數值,花色)
		ull temp_array[NUMBER_TO_DEALT] = { 0 };

		/*核心模擬*/
		for (int i = 0; i < NUMBER_TO_DEALT; i++)
		{
			temp_array[i] = Flowers_Random(generator);

			//重複檢測
			bool is_same = false;
			for (int k = 0; k < i; k++)
			{
				//i0, i1 k0 , i2 k01 .. i2 == k01 , repeat
				if (temp_array[k] == temp_array[i])
				{
					i -= 1;
					is_same = true;
				}
			}

			if (is_same == false)
			{
				//儲存抽到的資料
				std::pair<int, int> newPoint = std::make_pair(temp_array[i] % NUMBER_OF_CARDS_PER_FLOWERS, temp_array[i] % NUMBER_OF_FLOWERS);
				points.push_back(newPoint);
			}


		}

		////排序second
		//std::sort(points.begin(), points.end(), [](const std::pair<int, int>& a, const std::pair<int, int>& b) {
		//	return a.second < b.second || (a.second == b.second && a.first < b.first);
		//	});

		//排序first
		std::sort(points.begin(), points.end(), [](const std::pair<int, int>& a, const std::pair<int, int>& b) {
			return a.first < b.first || (a.first == b.first && a.second < b.second);
			});


		//輸出抽取情況的函數
#if Probability_Final_Project_2_PRINT_MODE
		/*附加: 打印boolArray*/

		   // 輸出結果
		//抽到的點
		//for (const auto& point : points) {
		//	std::cout << "(" << point.first << ", " << point.second << ")";
		//}
		//std::cout << '\n';

		////完整打印所有的東西，包括沒抽到的
		//std::cout << "=========================\n";
		//for (int i = 0; i < NUMBER_OF_FLOWERS; i++)
		//{
		//	for (int k = 0; k < NUMBER_OF_CARDS_PER_FLOWERS; k++)
		//	{
		//		bool trigger_flag = false;
		//		//if (k,1) = point , 則輸出1
		//		for (const auto& point : points) {
		//			//所有的點都不是 輸出1 
		//			if (k == point.first && i == point.second)
		//			{
		//				trigger_flag = true;
		//			}
		//		}
		//		if (trigger_flag == true)
		//		{
		//			printf("\033[31m1\033[0m ");
		//		}
		//		else
		//		{
		//			std::cout << "0 ";
		//		}
		//	}
		//	std::cout << '\n';
		//}
		//std::cout << "=========================\n";

#endif//Probability_Final_Project_2_PRINT_MODE

		//(a)Straight順子, a 可以當10,11,12,13,0 或 0,1,2,3,4,5
#if !Probability_Final_Project_2_STRAIGHT_STOP_MODE 

		bool isStraight = false;
		if (points[0].first == 0 && points[1].first == 9 && points[2].first == 10 && points[3].first == 11 && points[4].first == 12) {
			isStraight = true;
		}
		else {
			bool consecutive = true;
			for (int k = 0; k < 4; k++) {
				if (points[k].first + 1 != points[k + 1].first) {
					consecutive = false;
					break;
				}
			}
			if (consecutive) {
				isStraight = true;
			}
		}
		if (isStraight) {
			straightSuccess++;
#if Probability_Final_Project_2_PRINT_MODE
			//抽到的點
			for (const auto& point : points) {
				std::cout << "(" << point.first << ", " << point.second << ")";
			}
			std::cout << '\n';

			printf("\033[38;2;255;165;0mStraight\033[0m\n");
#endif//Probability_Final_Project_2_PRINT_MODE
		}
#endif//Probability_Final_Project_2_STRAIGHT_STOP_MODE

		//(b)Full House葫蘆, 3同2同
#if !Probability_Final_Project_2_FULL_HOUSE_STOP_MODE
		//aabbb
		if ((points[0].first == points[1].first
			&& points[2].first == points[3].first
			&& points[3].first == points[4].first)
			|| (points[0].first == points[1].first
				&& points[1].first == points[2].first
				&& points[3].first == points[4].first)) {
#if Probability_Final_Project_2_PRINT_MODE
			//抽到的點
			for (const auto& point : points) {
				std::cout << "(" << point.first << ", " << point.second << ")";
			}
			std::cout << '\n';
			printf("\033[38;2;255;165;0mFull House\033[0m\n");
#endif//Probability_Final_Project_2_PRINT_MODE
			fullHouseSuccess += 1;
		}

#endif//Probability_Final_Project_2_FULL_HOUSE_STOP_MODE

		//(c)Flush同花, 5張同花色
#if !Probability_Final_Project_2_FLUSH_STOP_MODE
		if (points[0].second == points[1].second
			&& points[1].second == points[2].second
			&& points[2].second == points[3].second
			&& points[3].second == points[4].second) {
#if Probability_Final_Project_2_PRINT_MODE
			printf("\033[38;2;255;165;0mFlush\033[0m\n");
#endif//Probability_Final_Project_2_PRINT_MODE
			flushSuccess += 1;
		}
#endif//Probability_Final_Project_2_FLUSH_STOP_MODE

		//無限模式輸出結果
#if Probability_Final_Project_2_INFINITE_LOOP_MODE
		//此處需要使用兩個變量追蹤的原因是，boost浮點數沒有重載%運算符
		cpp_dec_float_numberOfExperimentRepeated += 1;
		ull_numberOfExperimentRepeated += 1;

		if (ull_numberOfExperimentRepeated % AFTER_X_EXPERIMENT_PRINT == 0)
		{
			std::cout << "Number of experiment repeated: " << cpp_dec_float_numberOfExperimentRepeated << '\n';
#if !Probability_Final_Project_2_STRAIGHT_STOP_MODE 
			//省略部分輸出以更加簡潔//std::cout << "Straight Success:" << straightSuccess << '\n';
			std::cout << "Straight Probability: " << std::setprecision(PRECISION) << straightSuccess / (cpp_dec_float_numberOfExperimentRepeated) << '\n';
#endif//Probability_Final_Project_2_STRAIGHT_STOP_MODE
#if !Probability_Final_Project_2_FULL_HOUSE_STOP_MODE
			//std::cout << "Full House Success:" << fullHouseSuccess << '\n';
			std::cout << "Full House Probability: " << std::setprecision(PRECISION) << fullHouseSuccess / (cpp_dec_float_numberOfExperimentRepeated) << '\n';
#endif//Probability_Final_Project_2_FULL_HOUSE_STOP_MODE
#if !Probability_Final_Project_2_FLUSH_STOP_MODE
			//std::cout << "Flush Success:" << flushSuccess << '\n';
			std::cout << "Flush Probability: " << std::setprecision(PRECISION) << flushSuccess / (cpp_dec_float_numberOfExperimentRepeated) << '\n';
#endif//Probability_Final_Project_2_FLUSH_STOP_MODE
			std::cout << '\n';

		}

#endif//Probability_Final_Project_1_INFINITE_LOOP_MODE

	}
	//正常模式輸出結果
#if !Probability_Final_Project_2_INFINITE_LOOP_MODE

	std::cout << "Number of experiment repeated: " << NUMBER_OF_EXPERIMENT_REPEATED << '\n';
#if !Probability_Final_Project_2_STRAIGHT_STOP_MODE 
	//省略部分輸出以更加簡潔//std::cout << "Straight Success:" << straightSuccess << '\n';
	std::cout << "Straight Probability: " << std::setprecision(PRECISION) << straightSuccess / (NUMBER_OF_EXPERIMENT_REPEATED) << '\n';
#endif//Probability_Final_Project_2_STRAIGHT_STOP_MODE
#if !Probability_Final_Project_2_FULL_HOUSE_STOP_MODE
	//std::cout << "Full House Success:" << fullHouseSuccess << '\n';
	std::cout << "Full House Probability: " << std::setprecision(PRECISION) << fullHouseSuccess / (NUMBER_OF_EXPERIMENT_REPEATED) << '\n';
#endif//Probability_Final_Project_2_FULL_HOUSE_STOP_MODE
#if !Probability_Final_Project_2_FLUSH_STOP_MODE
	//std::cout << "Flush Success:" << flushSuccess << '\n';
	std::cout << "Flush Probability: " << std::setprecision(PRECISION) << flushSuccess / (NUMBER_OF_EXPERIMENT_REPEATED) << '\n';
#endif//Probability_Final_Project_2_FLUSH_STOP_MODE
	std::cout << '\n';

#endif//!Probability_Final_Project_2_INFINITE_LOOP_MODE

#endif //Probability_Final_Project_2_STOP_MODE
	}


void funcPart02()
{

}

void funcPart03()
{



}

void funcPart04()
{



}


void funcPart05()
{

}


void funcPart06()
{


}



void funcPart07()
{


}


void funcPart08()
{

}

void funcPart09()
{

}



void funcPart10()
{

}

